// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: dml.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const authenticatedEmailFetch = `-- name: AuthenticatedEmailFetch :one
SELECT u_id, u_username, u_flags, u_comment
FROM users
WHERE u_email = ?
  AND u_password = ?
`

type AuthenticatedEmailFetchParams struct {
	UEmail    string
	UPassword sql.NullString
}

type AuthenticatedEmailFetchRow struct {
	UID       int64
	UUsername string
	UFlags    sql.NullInt64
	UComment  sql.NullString
}

func (q *Queries) AuthenticatedEmailFetch(ctx context.Context, arg AuthenticatedEmailFetchParams) (AuthenticatedEmailFetchRow, error) {
	row := q.db.QueryRowContext(ctx, authenticatedEmailFetch, arg.UEmail, arg.UPassword)
	var i AuthenticatedEmailFetchRow
	err := row.Scan(
		&i.UID,
		&i.UUsername,
		&i.UFlags,
		&i.UComment,
	)
	return i, err
}

const authenticatedUserFetch = `-- name: AuthenticatedUserFetch :one
SELECT u_id, u_username, u_flags, u_comment
FROM users
WHERE u_username = ?
  AND u_password = ?
`

type AuthenticatedUserFetchParams struct {
	UUsername string
	UPassword sql.NullString
}

type AuthenticatedUserFetchRow struct {
	UID       int64
	UUsername string
	UFlags    sql.NullInt64
	UComment  sql.NullString
}

func (q *Queries) AuthenticatedUserFetch(ctx context.Context, arg AuthenticatedUserFetchParams) (AuthenticatedUserFetchRow, error) {
	row := q.db.QueryRowContext(ctx, authenticatedUserFetch, arg.UUsername, arg.UPassword)
	var i AuthenticatedUserFetchRow
	err := row.Scan(
		&i.UID,
		&i.UUsername,
		&i.UFlags,
		&i.UComment,
	)
	return i, err
}

const clanFetch = `-- name: ClanFetch :one
SELECT c_id,
       c_name,
       c_password,
       c_members,
       e_id_leader,
       e_id_asst,
       e_id_fa1,
       e_id_fa2,
       c_title,
       c_url,
       c_pic
FROM clan
WHERE c_id = ?
`

func (q *Queries) ClanFetch(ctx context.Context, cID int64) (Clan, error) {
	row := q.db.QueryRowContext(ctx, clanFetch, cID)
	var i Clan
	err := row.Scan(
		&i.CID,
		&i.CName,
		&i.CPassword,
		&i.CMembers,
		&i.EIDLeader,
		&i.EIDAsst,
		&i.EIDFa1,
		&i.EIDFa2,
		&i.CTitle,
		&i.CUrl,
		&i.CPic,
	)
	return i, err
}

const empireActiveUserCount = `-- name: EmpireActiveUserCount :one
SELECT COUNT(*)
FROM empire
WHERE u_id != 0
`

func (q *Queries) EmpireActiveUserCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, empireActiveUserCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const empireAttributesUpdate = `-- name: EmpireAttributesUpdate :exec
UPDATE empire
SET e_flags       = ?,
    e_valcode     = ?,
    e_reason      = ?,
    e_vacation    = ?,
    e_idle        = ?,
    e_era         = ?,
    e_rank        = ?,
    e_sharing     = ?,
    e_attacks     = ?,
    e_offsucc     = ?,
    e_offtotal    = ?,
    e_defsucc     = ?,
    e_deftotal    = ?,
    e_kills       = ?,
    e_score       = ?,
    e_killedby    = ?,
    e_killclan    = ?,
    e_turns       = ?,
    e_storedturns = ?,
    e_turnsused   = ?,
    e_networth    = ?,
    e_cash        = ?,
    e_food        = ?,
    e_peasants    = ?,
    e_trparm      = ?,
    e_trplnd      = ?,
    e_trpfly      = ?,
    e_trpsea      = ?,
    e_trpwiz      = ?,
    e_health      = ?,
    e_runes       = ?,
    e_indarm      = ?,
    e_indlnd      = ?,
    e_indfly      = ?,
    e_indsea      = ?,
    e_land        = ?,
    e_bldpop      = ?,
    e_bldcash     = ?,
    e_bldtrp      = ?,
    e_bldcost     = ?,
    e_bldwiz      = ?,
    e_bldfood     = ?,
    e_blddef      = ?,
    e_freeland    = ?,
    e_tax         = ?,
    e_bank        = ?,
    e_loan        = ?,
    e_mktarm      = ?,
    e_mktlnd      = ?,
    e_mktfly      = ?,
    e_mktsea      = ?,
    e_mktfood     = ?,
    e_mktperarm   = ?,
    e_mktperlnd   = ?,
    e_mktperfly   = ?,
    e_mktpersea   = ?
WHERE e_id = ?
`

type EmpireAttributesUpdateParams struct {
	EFlags       sql.NullInt64
	EValcode     sql.NullString
	EReason      sql.NullString
	EVacation    sql.NullInt64
	EIdle        sql.NullInt64
	EEra         sql.NullInt64
	ERank        sql.NullInt64
	ESharing     sql.NullInt64
	EAttacks     sql.NullInt64
	EOffsucc     sql.NullInt64
	EOfftotal    sql.NullInt64
	EDefsucc     sql.NullInt64
	EDeftotal    sql.NullInt64
	EKills       sql.NullInt64
	EScore       sql.NullInt64
	EKilledby    sql.NullInt64
	EKillclan    sql.NullInt64
	ETurns       sql.NullInt64
	EStoredturns sql.NullInt64
	ETurnsused   sql.NullInt64
	ENetworth    sql.NullInt64
	ECash        sql.NullInt64
	EFood        sql.NullInt64
	EPeasants    sql.NullInt64
	ETrparm      sql.NullInt64
	ETrplnd      sql.NullInt64
	ETrpfly      sql.NullInt64
	ETrpsea      sql.NullInt64
	ETrpwiz      sql.NullInt64
	EHealth      sql.NullInt64
	ERunes       sql.NullInt64
	EIndarm      sql.NullInt64
	EIndlnd      sql.NullInt64
	EIndfly      sql.NullInt64
	EIndsea      sql.NullInt64
	ELand        sql.NullInt64
	EBldpop      sql.NullInt64
	EBldcash     sql.NullInt64
	EBldtrp      sql.NullInt64
	EBldcost     sql.NullInt64
	EBldwiz      sql.NullInt64
	EBldfood     sql.NullInt64
	EBlddef      sql.NullInt64
	EFreeland    sql.NullInt64
	ETax         sql.NullInt64
	EBank        sql.NullInt64
	ELoan        sql.NullInt64
	EMktarm      sql.NullInt64
	EMktlnd      sql.NullInt64
	EMktfly      sql.NullInt64
	EMktsea      sql.NullInt64
	EMktfood     sql.NullInt64
	EMktperarm   sql.NullInt64
	EMktperlnd   sql.NullInt64
	EMktperfly   sql.NullInt64
	EMktpersea   sql.NullInt64
	EID          int64
}

func (q *Queries) EmpireAttributesUpdate(ctx context.Context, arg EmpireAttributesUpdateParams) error {
	_, err := q.db.ExecContext(ctx, empireAttributesUpdate,
		arg.EFlags,
		arg.EValcode,
		arg.EReason,
		arg.EVacation,
		arg.EIdle,
		arg.EEra,
		arg.ERank,
		arg.ESharing,
		arg.EAttacks,
		arg.EOffsucc,
		arg.EOfftotal,
		arg.EDefsucc,
		arg.EDeftotal,
		arg.EKills,
		arg.EScore,
		arg.EKilledby,
		arg.EKillclan,
		arg.ETurns,
		arg.EStoredturns,
		arg.ETurnsused,
		arg.ENetworth,
		arg.ECash,
		arg.EFood,
		arg.EPeasants,
		arg.ETrparm,
		arg.ETrplnd,
		arg.ETrpfly,
		arg.ETrpsea,
		arg.ETrpwiz,
		arg.EHealth,
		arg.ERunes,
		arg.EIndarm,
		arg.EIndlnd,
		arg.EIndfly,
		arg.EIndsea,
		arg.ELand,
		arg.EBldpop,
		arg.EBldcash,
		arg.EBldtrp,
		arg.EBldcost,
		arg.EBldwiz,
		arg.EBldfood,
		arg.EBlddef,
		arg.EFreeland,
		arg.ETax,
		arg.EBank,
		arg.ELoan,
		arg.EMktarm,
		arg.EMktlnd,
		arg.EMktfly,
		arg.EMktsea,
		arg.EMktfood,
		arg.EMktperarm,
		arg.EMktperlnd,
		arg.EMktperfly,
		arg.EMktpersea,
		arg.EID,
	)
	return err
}

const empireCreate = `-- name: EmpireCreate :one
INSERT INTO empire (u_id, e_name, e_race)
VALUES (?, ?, ?)
RETURNING e_id
`

type EmpireCreateParams struct {
	UID   int64
	EName string
	ERace int64
}

func (q *Queries) EmpireCreate(ctx context.Context, arg EmpireCreateParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, empireCreate, arg.UID, arg.EName, arg.ERace)
	var e_id int64
	err := row.Scan(&e_id)
	return e_id, err
}

const empireUpdateFlags = `-- name: EmpireUpdateFlags :exec
UPDATE empire
SET e_flags = ?
WHERE e_id = ?
`

type EmpireUpdateFlagsParams struct {
	EFlags sql.NullInt64
	EID    int64
}

func (q *Queries) EmpireUpdateFlags(ctx context.Context, arg EmpireUpdateFlagsParams) error {
	_, err := q.db.ExecContext(ctx, empireUpdateFlags, arg.EFlags, arg.EID)
	return err
}

const userAccessUpdate = `-- name: UserAccessUpdate :one
UPDATE users
SET u_lastip   = ?,
    u_lastdate = datetime('now')
WHERE u_id = ?
RETURNING u_lastdate
`

type UserAccessUpdateParams struct {
	ULastip sql.NullString
	UID     int64
}

func (q *Queries) UserAccessUpdate(ctx context.Context, arg UserAccessUpdateParams) (sql.NullTime, error) {
	row := q.db.QueryRowContext(ctx, userAccessUpdate, arg.ULastip, arg.UID)
	var u_lastdate sql.NullTime
	err := row.Scan(&u_lastdate)
	return u_lastdate, err
}

const userActiveEmpires = `-- name: UserActiveEmpires :many
SELECT e_id, e_flags
FROM empire
WHERE u_id = ?
  AND e_flags & ? = 0
ORDER BY e_id
`

type UserActiveEmpiresParams struct {
	UID    int64
	EFlags sql.NullInt64
}

type UserActiveEmpiresRow struct {
	EID    int64
	EFlags sql.NullInt64
}

func (q *Queries) UserActiveEmpires(ctx context.Context, arg UserActiveEmpiresParams) ([]UserActiveEmpiresRow, error) {
	rows, err := q.db.QueryContext(ctx, userActiveEmpires, arg.UID, arg.EFlags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserActiveEmpiresRow
	for rows.Next() {
		var i UserActiveEmpiresRow
		if err := rows.Scan(&i.EID, &i.EFlags); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userAttributesUpdate = `-- name: UserAttributesUpdate :one
UPDATE users
SET u_flags      = ?,
    u_name       = ?,
    u_comment    = ?,
    u_timezone   = ?,
    u_style      = ?,
    u_lang       = ?,
    u_dateformat = ?,
    u_lastip     = ?,
    u_kills      = ?,
    u_deaths     = ?,
    u_offsucc    = ?,
    u_offtotal   = ?,
    u_defsucc    = ?,
    u_deftotal   = ?,
    u_numplays   = ?,
    u_sucplays   = ?,
    u_avgrank    = ?,
    u_bestrank   = ?,
    u_lastdate   = datetime('now')
WHERE u_id = ?
RETURNING u_lastdate
`

type UserAttributesUpdateParams struct {
	UFlags      sql.NullInt64
	UName       sql.NullString
	UComment    sql.NullString
	UTimezone   sql.NullInt64
	UStyle      sql.NullString
	ULang       sql.NullString
	UDateformat sql.NullString
	ULastip     sql.NullString
	UKills      sql.NullInt64
	UDeaths     sql.NullInt64
	UOffsucc    sql.NullInt64
	UOfftotal   sql.NullInt64
	UDefsucc    sql.NullInt64
	UDeftotal   sql.NullInt64
	UNumplays   sql.NullInt64
	USucplays   sql.NullInt64
	UAvgrank    sql.NullFloat64
	UBestrank   sql.NullFloat64
	UID         int64
}

func (q *Queries) UserAttributesUpdate(ctx context.Context, arg UserAttributesUpdateParams) (sql.NullTime, error) {
	row := q.db.QueryRowContext(ctx, userAttributesUpdate,
		arg.UFlags,
		arg.UName,
		arg.UComment,
		arg.UTimezone,
		arg.UStyle,
		arg.ULang,
		arg.UDateformat,
		arg.ULastip,
		arg.UKills,
		arg.UDeaths,
		arg.UOffsucc,
		arg.UOfftotal,
		arg.UDefsucc,
		arg.UDeftotal,
		arg.UNumplays,
		arg.USucplays,
		arg.UAvgrank,
		arg.UBestrank,
		arg.UID,
	)
	var u_lastdate sql.NullTime
	err := row.Scan(&u_lastdate)
	return u_lastdate, err
}

const userCreate = `-- name: UserCreate :one

INSERT INTO users (u_username, u_email, u_createdate, u_lastdate)
VALUES (?, ?, datetime('now'), datetime('now'))
RETURNING u_id, u_createdate, u_lastdate
`

type UserCreateParams struct {
	UUsername string
	UEmail    string
}

type UserCreateRow struct {
	UID         int64
	UCreatedate sql.NullTime
	ULastdate   sql.NullTime
}

// Copyright (c) 2024 Michael D Henderson. All rights reserved.
func (q *Queries) UserCreate(ctx context.Context, arg UserCreateParams) (UserCreateRow, error) {
	row := q.db.QueryRowContext(ctx, userCreate, arg.UUsername, arg.UEmail)
	var i UserCreateRow
	err := row.Scan(&i.UID, &i.UCreatedate, &i.ULastdate)
	return i, err
}

const userFetch = `-- name: UserFetch :one
SELECT u_username, u_flags, u_comment, u_timezone
FROM users
WHERE u_id = ?
`

type UserFetchRow struct {
	UUsername string
	UFlags    sql.NullInt64
	UComment  sql.NullString
	UTimezone sql.NullInt64
}

func (q *Queries) UserFetch(ctx context.Context, uID int64) (UserFetchRow, error) {
	row := q.db.QueryRowContext(ctx, userFetch, uID)
	var i UserFetchRow
	err := row.Scan(
		&i.UUsername,
		&i.UFlags,
		&i.UComment,
		&i.UTimezone,
	)
	return i, err
}

const userPasswordUpdate = `-- name: UserPasswordUpdate :one
UPDATE users
SET u_password = ?,
    u_lastdate = datetime('now')
WHERE u_id = ?
RETURNING u_lastdate
`

type UserPasswordUpdateParams struct {
	UPassword sql.NullString
	UID       int64
}

func (q *Queries) UserPasswordUpdate(ctx context.Context, arg UserPasswordUpdateParams) (sql.NullTime, error) {
	row := q.db.QueryRowContext(ctx, userPasswordUpdate, arg.UPassword, arg.UID)
	var u_lastdate sql.NullTime
	err := row.Scan(&u_lastdate)
	return u_lastdate, err
}

const worldVarsFetch = `-- name: WorldVarsFetch :one
SELECT wv_id,
       lotto_current_jackpot,
       lotto_yesterday_jackpot,
       lotto_last_picked,
       lotto_last_winner,
       lotto_jackpot_increase,
       round_time_begin,
       round_time_closing,
       round_time_end,
       turns_next,
       turns_next_hourly,
       turns_next_daily
FROM world_vars
`

func (q *Queries) WorldVarsFetch(ctx context.Context) (WorldVar, error) {
	row := q.db.QueryRowContext(ctx, worldVarsFetch)
	var i WorldVar
	err := row.Scan(
		&i.WvID,
		&i.LottoCurrentJackpot,
		&i.LottoYesterdayJackpot,
		&i.LottoLastPicked,
		&i.LottoLastWinner,
		&i.LottoJackpotIncrease,
		&i.RoundTimeBegin,
		&i.RoundTimeClosing,
		&i.RoundTimeEnd,
		&i.TurnsNext,
		&i.TurnsNextHourly,
		&i.TurnsNextDaily,
	)
	return i, err
}

const worldVarsInitialize = `-- name: WorldVarsInitialize :exec
INSERT INTO world_vars(lotto_current_jackpot, lotto_yesterday_jackpot, lotto_last_picked, lotto_last_winner,
                       lotto_jackpot_increase, round_time_begin, round_time_closing, round_time_end, turns_next,
                       turns_next_hourly, turns_next_daily)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type WorldVarsInitializeParams struct {
	LottoCurrentJackpot   int64
	LottoYesterdayJackpot int64
	LottoLastPicked       int64
	LottoLastWinner       int64
	LottoJackpotIncrease  int64
	RoundTimeBegin        time.Time
	RoundTimeClosing      time.Time
	RoundTimeEnd          time.Time
	TurnsNext             time.Time
	TurnsNextHourly       time.Time
	TurnsNextDaily        time.Time
}

func (q *Queries) WorldVarsInitialize(ctx context.Context, arg WorldVarsInitializeParams) error {
	_, err := q.db.ExecContext(ctx, worldVarsInitialize,
		arg.LottoCurrentJackpot,
		arg.LottoYesterdayJackpot,
		arg.LottoLastPicked,
		arg.LottoLastWinner,
		arg.LottoJackpotIncrease,
		arg.RoundTimeBegin,
		arg.RoundTimeClosing,
		arg.RoundTimeEnd,
		arg.TurnsNext,
		arg.TurnsNextHourly,
		arg.TurnsNextDaily,
	)
	return err
}

const worldVarsUpdate = `-- name: WorldVarsUpdate :exec
UPDATE world_vars
SET lotto_current_jackpot   = ?,
    lotto_yesterday_jackpot = ?,
    lotto_last_picked       = ?,
    lotto_last_winner       = ?,
    lotto_jackpot_increase  = ?,
    round_time_begin        = ?,
    round_time_closing      = ?,
    round_time_end          = ?,
    turns_next              = ?,
    turns_next_hourly       = ?,
    turns_next_daily        = ?
`

type WorldVarsUpdateParams struct {
	LottoCurrentJackpot   int64
	LottoYesterdayJackpot int64
	LottoLastPicked       int64
	LottoLastWinner       int64
	LottoJackpotIncrease  int64
	RoundTimeBegin        time.Time
	RoundTimeClosing      time.Time
	RoundTimeEnd          time.Time
	TurnsNext             time.Time
	TurnsNextHourly       time.Time
	TurnsNextDaily        time.Time
}

func (q *Queries) WorldVarsUpdate(ctx context.Context, arg WorldVarsUpdateParams) error {
	_, err := q.db.ExecContext(ctx, worldVarsUpdate,
		arg.LottoCurrentJackpot,
		arg.LottoYesterdayJackpot,
		arg.LottoLastPicked,
		arg.LottoLastWinner,
		arg.LottoJackpotIncrease,
		arg.RoundTimeBegin,
		arg.RoundTimeClosing,
		arg.RoundTimeEnd,
		arg.TurnsNext,
		arg.TurnsNextHourly,
		arg.TurnsNextDaily,
	)
	return err
}
